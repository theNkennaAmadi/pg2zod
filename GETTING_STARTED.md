# Getting Started with pg-to-zod

This guide will help you get started with generating Zod schemas from your PostgreSQL database.

## Prerequisites

- Node.js 18 or higher
- PostgreSQL database (local or remote)
- Basic knowledge of TypeScript and Zod

## Installation

```bash
npm install pg-to-zod
# or
pnpm add pg-to-zod
# or
yarn add pg-to-zod
```

## Quick Start

### 1. Set up a Test Database (Optional)

If you want to test the package with the included example schema:

```bash
# Create a test database
createdb pg_to_zod_test

# Load the example schema
psql -d pg_to_zod_test -f example-schema.sql
```

### 2. Generate Schemas via CLI

The simplest way to use pg-to-zod is through the CLI:

```bash
# Basic usage (generates Read, Insert, and Update schemas by default)
npx pg-to-zod --database pg_to_zod_test --output src/db-schema.ts

# Using connection URL (recommended)
npx pg-to-zod \
  --url postgresql://user:password@localhost:5432/pg_to_zod_test \
  --output src/db-schema.ts

# With all options
npx pg-to-zod \
  --database pg_to_zod_test \
  --user postgres \
  --password yourpassword \
  --output src/db-schema.ts \
  --composite-types \
  --camel-case

# Skip input schemas if you only need Read schemas
npx pg-to-zod --database mydb --no-input-schemas -o schema.ts
```

### 3. Use Programmatically

Create a script to generate schemas:

```typescript
import { generateZodSchemasString } from 'pg-to-zod';
import { writeFile } from 'fs/promises';

async function generateSchemas() {
  const schemas = await generateZodSchemasString(
    {
      host: 'localhost',
      port: 5432,
      database: 'pg_to_zod_test',
      user: 'postgres',
      password: 'yourpassword',
    },
    {
      schemas: ['public'],
      generateInputSchemas: true,
      includeComments: true,
    }
  );

  await writeFile('src/db-schema.ts', schemas);
  console.log('âœ… Schemas generated!');
}

generateSchemas();
```

## Generated Output

Given this PostgreSQL schema:

```sql
CREATE TYPE user_role AS ENUM ('admin', 'user', 'guest');

CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  username VARCHAR(50) NOT NULL,
  email VARCHAR(255) NOT NULL,
  role user_role DEFAULT 'user',
  age INTEGER CHECK (age >= 18),
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

pg-to-zod generates:

```typescript
// Generated by pg-to-zod
import { z } from 'zod';

// ============================================
// Enums
// ============================================

/** Enum: public.user_role */
export const PublicUserRoleSchema = z.enum(['admin', 'user', 'guest']);
export type PublicUserRole = z.infer<typeof PublicUserRoleSchema>;

// ============================================
// Tables
// ============================================

/** Table: public.users - Read schema */
export const PublicUsersSchema = z.object({
  id: z.number().int(),
  username: z.string().max(50),
  email: z.string().max(255),
  role: PublicUserRoleSchema,
  age: z.number().int().min(18).nullable(),
  created_at: z.date(),
});
export type PublicUsers = z.infer<typeof PublicUsersSchema>;

/** Insert schema for users */
export const PublicUsersInsertSchema = z.object({
  id: z.number().int().optional(), // auto-generated
  username: z.string().max(50),
  email: z.string().max(255),
  role: PublicUserRoleSchema.optional(), // has default
  age: z.number().int().min(18).nullable(),
  created_at: z.date().optional(), // has default
});
export type PublicUsersInsert = z.infer<typeof PublicUsersInsertSchema>;

/** Update schema for users */
export const PublicUsersUpdateSchema = z.object({
  username: z.string().max(50).optional(),
  email: z.string().max(255).optional(),
  role: PublicUserRoleSchema.optional(),
  age: z.number().int().min(18).optional().nullable(),
  created_at: z.date().optional(),
});
export type PublicUsersUpdate = z.infer<typeof PublicUsersUpdateSchema>;
```

## Using Generated Schemas

Once you have generated the schemas, you can use them for validation:

```typescript
import { 
  PublicUsersSchema, 
  PublicUsers,
  PublicUsersInsertSchema,
  PublicUsersInsert,
  PublicUsersUpdateSchema,
  PublicUsersUpdate
} from './db-schema.js';

// Validate data from database
const dbUser = await db.query('SELECT * FROM users WHERE id = $1', [1]);
const validatedUser = PublicUsersSchema.parse(dbUser.rows[0]);

// Validate user input before insert - use Insert schema
const newUserData = {
  username: 'john_doe',
  email: 'john@example.com',
  // role and created_at are optional (have defaults)
  age: null, // nullable field
};

try {
  const validated = PublicUsersInsertSchema.parse(newUserData);
  await db.query(
    'INSERT INTO users (username, email, age) VALUES ($1, $2, $3)',
    [validated.username, validated.email, validated.age]
  );
} catch (error) {
  console.error('Validation failed:', error);
}

// Validate partial update - use Update schema
const updateData = {
  email: 'newemail@example.com',
  // Other fields omitted - all fields optional in update schema
};

const validatedUpdate = PublicUsersUpdateSchema.parse(updateData);
await db.query(
  'UPDATE users SET email = $1 WHERE id = $2', 
  [validatedUpdate.email, 1]
);

// Type inference
const user: PublicUsers = {
  id: 1,
  username: 'john_doe',
  email: 'john@example.com',
  role: 'user',
  age: 25,
  created_at: new Date(),
};
```

## Advanced Usage

### Input Schemas (Generated by Default)

By default, pg-to-zod generates three schemas per table:
1. **Read schema** (`PublicUsersSchema`) - Reflects actual database structure
2. **Insert schema** (`PublicUsersInsertSchema`) - Auto-generated fields and fields with defaults are optional
3. **Update schema** (`PublicUsersUpdateSchema`) - All fields optional (for partial updates), primary keys excluded

To skip input schemas if you only need Read schemas:
```bash
npx pg-to-zod --database mydb --no-input-schemas -o schema.ts
```

### Composite Types

By default, composite types are skipped to avoid naming conflicts. To include them:
```bash
npx pg-to-zod --database mydb --composite-types -o schema.ts
```

### camelCase Field Names

Convert snake_case database fields to camelCase:

```bash
npx pg-to-zod --database mydb --camel-case -o schema.ts
```

### Custom Type Mappings

When using the programmatic API, you can provide custom type mappings:

```typescript
const result = await generateZodSchemas(config, {
  customTypeMappings: {
    'my_custom_type': 'z.string().regex(/^[A-Z]{3}$/)',
  },
});
```

### Strict Mode

Fail on unmapped types instead of using `z.unknown()`:

```bash
npx pg-to-zod --database mydb --strict -o schema.ts
```

## Environment Variables

Instead of passing credentials via CLI, use environment variables:

```bash
export PGHOST=localhost
export PGPORT=5432
export PGDATABASE=mydb
export PGUSER=postgres
export PGPASSWORD=secretpassword

npx pg-to-zod -o schema.ts
```

## Integration with Build Process

Add to your `package.json`:

```json
{
  "scripts": {
    "generate-schemas": "pg-to-zod --database mydb -o src/generated/schema.ts",
    "prebuild": "npm run generate-schemas",
    "build": "tsc"
  }
}
```

## CI/CD Integration

Example GitHub Actions workflow:

```yaml
name: Generate DB Schemas

on:
  push:
    branches: [main]

jobs:
  generate:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm install
      - run: npm run generate-schemas
      - run: npm run build
```

## Tips & Best Practices

1. **Version Control**: Commit generated schemas to version control for type safety across your team
2. **Regenerate Regularly**: Set up a script to regenerate schemas when your database schema changes
3. **Review Generated Code**: Always review generated schemas to ensure they match your expectations
4. **Customize as Needed**: Use custom type mappings for domain-specific types
5. **Separate by Schema**: Generate separate files for different PostgreSQL schemas using the `--schemas` option

## Troubleshooting

### Connection Issues

If you can't connect to your database:

```bash
# Test connection with psql
psql -h localhost -U postgres -d mydb

# Check PostgreSQL is running
pg_isready -h localhost -p 5432
```

### Unmapped Types

If you encounter unmapped types, you can:

1. Use custom type mappings
2. Run without `--strict` mode
3. Open an issue on GitHub with the type details

### Permission Issues

Make sure your database user has permission to:

```sql
GRANT SELECT ON ALL TABLES IN SCHEMA public TO your_user;
GRANT USAGE ON SCHEMA public TO your_user;
```

## Next Steps

- Read the [README](./README.md) for comprehensive documentation
- Check the [example schema](./example-schema.sql) for more examples
- Review the [TypeScript types](./src/types.ts) for API reference

## Support

If you encounter issues:

1. Check the [README](./README.md)
2. Look at the example files
3. Open an issue on GitHub

Happy coding! ðŸš€
